% !TEX encoding   = UTF8
% !TEX spellcheck = ru_RU
% !TEX root = ../seminars.tex

%%======================================
\chapter{Простые исполнители алгоритмов}
%%======================================

%%=========================
\section{Конечные автоматы}
%%=========================
Конечные автоматы "--- это простейшие преобразователи входных данных в~выходные данные. Их обычно рассматривают как \emph{потоковые} преобразователи, то есть такие исполнители, которые потенциально могут работать сколь угодно долго, получая на~вход поток символов и печатая на~выход преобразованный поток символов.

\theoremstyle{definition}
\newtheorem{definition}{Определение}

\begin{definition}
  Конечный автомат~\(\mathcal M\) задаётся множеством из~пяти элементов: конечное множество состояний~\(K\), конечный алфавит~\(B\), начальное состояние \(s_0\in K\), подмножество состояний останова \(F\subset K\) и функция перехода \(\pi\colon K\times B \rightarrow K\):
  \[
    \mathcal M = \left\{ B, K, \pi, s_0, F \right\},\quad s_0\in K,~~F\subset K,~~\pi\colon K\times B \rightarrow K.
  \]
\end{definition}

Алгоритм исполнения конечного автомата с~действиями:
\begin{tabbing}
  \(x \leftarrow s_0\) \\
  \codebf{while \(x \notin F\) do} \\
  \quad\= \(b\leftarrow \text{считать символ}\) \\
  \> \(\left(x, a\right)\leftarrow \pi\left(x, b\right)\) \\
  \> выполнить действие \(a\) \\
  \codebf{end while}
\end{tabbing}



%%=======================
\section{Машины Тьюринга}
%%=======================
Можно считать, что машина Тьюринга "--- это обобщённый конечный автомат, в~который добавлены дополнительные элементы:
\begin{itemize}
  \item специальное запоминающее устройство "--- бесконечная лента, состоящая из~ячеек памяти, в~которых могут хранится символы;
  \item возможность совершать определённые действия во~время переходов между состояниями, а именно, двигаться вдоль ленты, читать содержимое ячеек ленты и записывать в~них новые значения.
\end{itemize}

Алгоритм исполнения машин Тьюринга:
\begin{tabbing}
  \(x \leftarrow s_0\) \\
  \codebf{while \(x \notin F\) do} \\
  \quad\= \(b\leftarrow \text{значение активной ячейки}\) \\
  \> \(\left(x, b, a\right)\leftarrow \pi\left(x, b\right)\) \\
  \> \(\text{значение активной ячейки}\leftarrow b\) \\
  \> выполнить действие \(a\) \\
  \codebf{end while}
\end{tabbing}



%%=============================================
\paragraph{Машины Тьюринга и алгорифмы Маркова}
%%=============================================
приведены далее в~нотации консольного эмулятора \name{turingmarkov}\footnote{\url{https://github.com/vslutov/turingmarkov}}, реализованного на~языке \lang{Python}.



%%=================
\paragraph{Пример.}
%%=================
Рассмотрим машину Тьюринга из~упражнения~\ref{ex:turing:parity}, которая реализует счётчик чётности:
\textfile{projects/sem03/parity_counter.turing}

Машина Тьюринга описывается таблицей, где столбцы соответствуют символу на~ленте в~активной ячейке, а каждая строка определяет некоторое состояние:
\begin{flushleft}\begin{tabular}{l@{~~--~~}l}
  0 & движение вправо с~удалением символов, пока количество единиц \textbf{чётно} \\
  1 & то же, пока количество единиц \textbf{нечётно} \\
\end{tabular}\end{flushleft}

Конец слова достигается, когда в~активной ячейке оказывается пробел (обозначаемый символом~<<\_>>). Каждая ячейка определяет значение функции перехода "--- тройку (новый символ, направление движения, новое состояние). Головка может двигаться влево~(L), вправо~(R) или же остаться на~месте~(N). Состояние~<<!>> считается состоянием останова.



%%=========================
\section{Алгорифмы Маркова}
%%=========================
Вычисления, основанные на~правилах, называются продукционными. Исполнитель алгорифмов Маркова "--- это простейший исполнитель, осуществляющий продукционные вычисления.

В~памяти этого исполнителя хранится одно слово~\(X\) конечной длины, составленное из~букв конечного алфавита~\(B\prime\). Оно изначально равно входному слову, а после останова "--- выходному слову (результату вычислений).

Алфавит входного слова~\(B\) является подмножеством алфавита~\(B\prime\). Так же как и в~машинах Тьюринга, во~время вычислений можно использовать дополнительные буквы из~\(B\prime\backslash B\), которые не~могут присутствовать во~входном слове.

Преобразование слова~\(X\) на~исполнителе алгорифмов Маркова происходит путём последовательности преобразований "--- замен одного подслова в~слове~\(X\) на~другое. Возможные замены описываются \textbf{правилами подстановки}.

Упорядоченное множество правил подстановки задаёт логику работы исполнителя. Совокупность правил и алфавитов~\(B\) и~\(B\prime\) называется \textbf{нормальным алгорифмом Маркова}, или просто \textbf{алгорифмом}.

Пусть~\(b\) и~\(b\prime\) "--- некоторые слова в~алфавите~\(B\prime\). Правило <<\(b\rightarrow b\prime\)>> означает, что первое слева вхождение подслова~\(b\) в~слове~\(X\) следует заменить на~слово~\(b\prime\). Это \textbf{правило} считается \textbf{применимым}, если слово~\(X\) содержит подслово~\(b\). Некоторые правила могут быть помечены как \textbf{правила останова}.

Алгоритм работы исполнителя алгорифмов Маркова:
\begin{tabbing}
  \(i \leftarrow 0\) \\
  \(X \leftarrow X_0\) \\
  \codebf{while true do} \\
  \quad
  \=\codebf{if }\(P_i\) применимо к~\(X\)\codebf{ then} \\
  \>\quad
  \=\(X\leftarrow P_i\left(X\right)\) \\
  \>\>\codebf{if }\(P_i\) "--- правило останова\codebf{ then} \\
  \>\>\quad
      \=завершение работы \\
  \>\>\codebf{end if} \\
  \>\>\(i\leftarrow 0\) \\
  \>\codebf{else} \\
  \>\>\(i\leftarrow i + 1\) \\
  \>\>\codebf{if \(i = n\) then} \\
  \>\>\>завершение работы \\
  \>\>\codebf{end if} \\
  \>\codebf{end if} \\
  \codebf{end while}
\end{tabbing}



%%=================
\paragraph{Пример.}
%%=================
Рассмотрим алгорифм из~упражнения~\ref{ex:markov:addx}, который приписывает букву~\(x\) к~входному слову в~алфавите \(B = \left\{0, 1\right\}\) справа:
\textfile[linenos]{projects/sem03/add_x.markov}

Поскольку изначально во~входном слове буква~\(x\) не~может содержаться, то первым сработает последнее правило. Оно заменит пустое подслово (\(b = \emptyset\)), которое содержится в~начале любого слова, на~\(x\). Затем будут срабатывать правила~1 и~2 до~тех пор, пока справа от~\(x\) не~останется ни~одной цифры. Тогда сработает правило~3, которое является правилом останова. Мы не~можем обойтись без~него, так как иначе вновь сработает правило~4 и появится ещё одна буква~\(x\). В~таком случае исполнитель будет работать бесконечно.



%%================
\WhatToReadSection
%%================
\citeauthor[лекции~1--3 и семинары~1--3, стр.~24--60]{Vorozhcov:2008:ru}



%%===============
\ExercisesSection
%%===============
Опишите машины Тьюринга, которые реализуют:
\begin{exercise}[series=statemachine]
\item\label{ex:turing:parity} Счётчик чётности. Выход машины Тьюринга равен~\code{0} или~\code{1} в~зависимости от~того, чётно или нечётно число единиц в~последовательности из~\code{0} и~\code{1}, записанной на~ленте. В~начальном состоянии головка видит первый левый символ.

\item\label{ex:turing:invert} Инверсию заданного слова в~алфавите \code{\{0,1\}}, то есть~\code{0} заменяет на~\code{1}, а~\code{1} "--- на~\code{0}.

\item\label{ex:turing:reverse} <<Переворачивание>> заданного слова в~алфавите \code{\{a,b,c\}}.
\end{exercise}


\bigskip
Запишите нормальные алгорифмы Маркова, которые реализуют:
\begin{exercise}[resume*=statemachine]
\item\label{ex:markov:addx} Приписывание буквы \code{x} к~входному слову в~алфавите \code{\{0,1\}} справа.

\item То же, что и в~упражнении~\ref{ex:turing:invert}.

\item То же, что и в~упражнении~\ref{ex:turing:reverse}.

\item Распознавание правильных скобочных выражений. Правильное скобочное выражение "--- это слово в~алфавите~\code{\{(,)\}}, которое может получиться, если из~арифметического выражения удалить все символы, кроме скобок. Примеры правильных скобочных выражений: пустое слово, \code{()}, \code{(())()}, \code{()()}, \code{((()))}. Примеры неправильных скобочных выражений: \code{)(}, \code{())(()}, \code{(}, \code{))))}, \code{((())}. Результат работы: слово \code{yes}, если скобочное выражение правильное, и слово \code{no} "--- иначе.

\item Увеличение данного натурального числа, записанного в~двоичной системе счисления, на~единицу. Вход: число~\code{n} "--- слово в~алфавите \code{\{0,1\}}. Выход: двоичная запись натурального числа \code{n+1}.
\end{exercise}