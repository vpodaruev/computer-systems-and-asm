% !TEX encoding   = UTF8
% !TEX spellcheck = ru_RU
% !TEX root = ../seminars.tex

%%=================
\chapter{Процедуры}
%%=================
Процедуры являются ключевой абстракцией в~разработке программного обеспечения. Они предоставляют способ оформления кода, который реализует некоторую функциональность с~заданным набором аргументов и, в случае необходимости, возвращаемым значением. Такая функция может быть вызвана из~другой точки программы. Хорошо спроектированное программное обеспечение использует процедуры как механизм абстракции, скрывая детали реализации и, в~то же время, предоставляя краткий и ясный интерфейс, определяющий, какие значения будут вычислены и какое действие процедура окажет на~состояние программы. Процедуры принимают разные формы в~разных языках программирования "--- функции, методы, подпрограммы, обработчики и т.\,п. "--- но все они обладают общим набором особенностей.

Для~организации процедур на~машинном уровне, необходимо учесть разные моменты. Предположим, что процедура~\code{P} вызывает процедуру~\code{Q}, затем~\code{Q} выполняется и возвращается обратно в~\code{P}. Эти действия включают в~себя один или несколько следующих механизмов:

{\parindent=0.5cm%
%
\smallskip
\hangindent=1.5cm\hangafter=1
\emph{Передача управления.} Счётчик команд должен быть установлен в~адрес первой команды процедуры~\code{Q} при~входе и затем переведён в~адрес первой инструкции~\code{P}, следующей за~вызовом~\code{Q}, при~возврате.

\smallskip
\hangindent=1.5cm\hangafter=1
\emph{Передача данных.} \code{P}~должна быть способна передать один или более параметров в~\code{Q}, а~\code{Q} "--- вернуть значение обратно в~\code{P}.

\smallskip
\hangindent=1.5cm\hangafter=1
\emph{Выделение и освобождение памяти.} \code{Q}~может потребоваться выделить память для~локальных переменных до~начала исполнения и, затем, освободить её перед возвратом.

}



%%========================
\section{Программный стек}
%%========================
Во~время выполнения процедуры~\code{Q} процедура~\code{P}, наряду со~всеми остальными процедурами в~цепочке вызовов, временно приостанавливается. Пока выполняется~\code{Q}, только ей необходимо выделять память под~локальные переменные или аргументы для~вызова другой процедуры. Следовательно, программа может управлять памятью, необходимой для~процедур, используя стек.

В~архитектуре \name{x86-64} стек растёт в~направлении младших адресов. Указатель стека \code{\%rsp} указывает на~вершину стека. Данные могут быть размещены в~стеке и изъяты оттуда, используя команды \code{pushq} и \code{popq}. Место под~данные без~начального значения может быть выделено в~стеке просто путём уменьшения значения указателя стека на~необходимую величину. Освобождение памяти выполняется таким же образом, путём увеличения указателя стека.

Когда процедуре необходимо больше памяти, чем могут хранить регистры, она выделяет место в~стеке. Эта область называется \emph{кадром стека} процедуры. Кадр текущей процедуры всегда расположен на~вершине стека. Когда процедура~\code{P} вызывает~\code{Q} она сохраняет в~стек \emph{адрес возврата}, который указывает, откуда следует возобновить выполнение процедуры~\code{P} после возврата из~\code{Q}. Адрес возврата будем считать частью кадра стека~\code{P}, поскольку он хранит состояние, имеющее значение для~\code{P}. Кадр стека для~большинства процедур имеет фиксированный размер, и память выделяется в~самом начале процедуры. Тем не~менее, для~некоторых процедур необходим стек переменного размера. Процедура~\code{P} может передать до~шести целочисленных значений (т.\,е. указателей и целых чисел) в~регистрах, но если~\code{Q} требует больше аргументов, то они должны быть сохранены в~стеке процедурой~\code{P} перед вызовом~\code{Q}.



%%===========================
\section{Передача управления}
%%===========================
Передача управления из~функции~\code{P} в~функцию~\code{Q} осуществляется установкой указателя команд в~адрес первой команды~\code{Q}. Однако, когда настаёт момент возврата из~\code{Q}, процессору необходима информация, откуда следует возобновить исполнение процедуры~\code{P}.

\begin{flushleft}\small\ttfamily\begin{tabular}{@{}ll>{\rmfamily}l@{}}
  \toprule
  \multicolumn{2}{@{}l}{\textrm{Инструкция}} & Пояснение \\
  \midrule
  \textbf{call} &  метка     &  вызов процедуры (прямой) \\
  \textbf{call} &  *операнд  &  вызов процедуры (косвенный) \\
  \textbf{ret}  &            &  возврат из~процедуры \\
  \bottomrule
\end{tabular}\end{flushleft}

В~машинах с~архитектурой \code{x86-64} эта информация записывается при~вызове процедуры~\code{Q} командой \code{call}~\code{Q}. Данная инструкция помещает адрес~\code{A} в~стек и устанавливает счётчик команд на~начало процедуры~\code{Q}. Адрес~\code{A} называют \emph{адресом возврата} "--- это адрес инструкции, следующей непосредственно за~командой \code{call}. В~дополнение к~команде \code{call} есть инструкция \code{ret}, которая извлекает~\code{A} из~стека и устанавливает счётчик команд в~это значение.



%%=======================
\section{Передача данных}
%%=======================
Первые шесть целочисленных аргументов процедуры размещаются в~регистрах согласно их порядку в~списке аргументов. Аргументы, меньшие 64-х бит, помещаются в~соответствующие части указанных 64-битных регистров.

\begin{flushleft}\small\ttfamily\begin{tabular}{@{}l llllll@{}}
  \toprule
  \multirow{2}{2.5cm}{\rmfamily Размер опе\-ранда, бит} & \multicolumn{6}{c@{}}{\rmfamily Номер аргумента} \\
  \cline{2-7}
  & 1 & 2 & 3 & 4 & 5 & 6 \\
  \midrule
  64 & \%rdi & \%rsi & \%rdx & \%rcx & \%r8  & \%r9 \\
  32 & \%edi & \%esi & \%edx & \%ecx & \%r8d & \%r9d \\
  16 & \%di  & \%si  & \%dx  & \%cx  & \%r8w & \%r9w \\
  8  & \%dil & \%sil & \%dl  & \%cl  & \%r8b & \%r9b \\
  \bottomrule
\end{tabular}\end{flushleft}



%%=====================
\paragraph{Упражнение.}
%%=====================
Функция на~\lang{C} \code{procprob} имеет четыре аргумента~\code{u}, \code{a}, \code{v} и \code{b}. Каждый из~них представляет собой либо число со~знаком, либо указатель на~число со~знаком. Аргументы имеют разные размеры. Ниже приведено тело функции:

\cfile[firstline=3, lastline=5]{projects/sem11/procprob.c}

\noindent Функция компилируется в~следующий код для~архитектуры \code{x86-64}:

\gasfile[firstline=5, lastline=10]{projects/sem11/procprob.s}

\noindent Определите порядок и типы параметров функции. Возможны два верных ответа.



%%===============================================
\section{Размещение локальных переменных в~стеке}
%%===============================================
Причинами размещения локальных переменных в~стеке часто оказываются:
\begin{itemfeature}
  \item Недостаточное количество регистров, чтобы поместить все локальные данные.
  \item К~локальной переменной применяется оператор взятия адреса~\code{\&}, так что компилятор вынужден генерировать адрес для~неё.
  \item Некоторые локальные переменные являются массивами или структурами, и, следовательно, компилятор должен обращаться к~их элементам, используя адресную арифметику и косвенный доступ.
\end{itemfeature}



%%===================================================
\section{Размещение локальных переменных в~регистрах}
%%===================================================
Набор программных регистров действует как разделяемый между всеми процедурами ресурс. Хотя, в~каждый момент времени активна лишь одна из~них, необходима гарантия, что когда одна процедура (\textenglish{caller}) вызывает другую (\textenglish{callee}), последняя не~перезапишет значения некоторых регистров, которые первая планировала использовать далее. По~этой причине в~архитектуре \code{x86-64} принят ряд соглашений об~использовании регистров, которые должны выполняться всеми процедурами, включая библиотечные функции.

По~соглашению, регистры~\code{\%rbx}, \code{\%rbp} и \code{\%r12}~-- \code{\%r15} классифицируются как \textenglish{callee-saved}, то есть их значения обязана сохранить вызываемая процедура. То есть, когда~\code{P} вызывает~\code{Q}, \code{Q} обязана сохранить значения этих регистров такими, какие они были до~её вызова. Процедура~\code{Q} может выполнить это либо не~изменяя их вообще, либо предварительно сохранив их в~стеке, а затем восстановив оттуда обратно. Используя это соглашение код функции~\code{P} может сохранить значение в~любом из~\textenglish{callee-saved} регистров, вызвать~\code{Q}, и затем использовать значение этого регистра без~риска его повреждения за~время вызова.

Все остальные регистры, за~исключением указателя стека~\code{\%rsp}, классифицируются как \textenglish{caller-saved}. Это означает, что они могут изменяться любой функцией. Если процедура~\code{P} хранит некоторые данные в~таком регистре и вызывает процедуру~\code{Q}, то, поскольку~\code{Q} может свободно менять этот регистр, то~\code{P} обязана сама позаботиться о~сохранении этого значения перед вызовом.



%%=========================================================
\section{Соглашения о~вызовах в~\name{Intel}~\name{x86-64}}
%%=========================================================
Опускаясь на~всё более и более низкие уровни абстракции, код становится всё менее переносимым. Так, в~64-битных операционных системах \name{Linux} и \name{Windows} приняты разные соглашения о~вызовах процедур и использовании регистров в~архитектуре \name{Intel}~\name{x86-64}.



{\newcommand{\Reg}[1]{\texttt{\small \%#1}}

%%======================================
\paragraph{\texttt{Linux} \texttt{x64}.}
%%======================================
Соглашения в~\name{Linux} подробно изложены выше (в~данном разделе) и кратко приведены в~таблице раздела~\ref{sect:registers} ранее. Для~удобства повторим эту таблицу ещё раз:
{\small\ttfamily\begin{longtable}[l]{@{}lll@{}}
\toprule
  Регистр & Соглашение & Пояснение \\
\endfirsthead
\midrule
  \Reg{rax} & return value & аккумулятор \\
  \Reg{rbx} & callee saved & база \\
  \Reg{rcx} & 4th argument & счётчик \\
  \Reg{rdx} & 3rd argument & данные \\[0.2em]
%
  \Reg{rsi} & 2nd argument & индекс источника \\
  \Reg{rdi} & 1st argument & индекс приёмника \\
  \Reg{rbp} & callee saved & указатель начала кадра стека процедуры \\
  \Reg{rsp} & stack pointer & \\[0.2em]
%
  \Reg{r8}  & 5th argument & регистр общего назначения \\
  \Reg{r9}  & 6th argument & регистр общего назначения \\
  \Reg{r10} & caller saved & регистр общего назначения \\
  \Reg{r11} & caller saved & регистр общего назначения \\[0.2em]
%
  \Reg{r12} & callee saved & регистр общего назначения \\
  \Reg{r13} & callee saved & регистр общего назначения \\
  \Reg{r14} & callee saved & регистр общего назначения \\
  \Reg{r15} & callee saved & регистр общего назначения \\
\bottomrule
\end{longtable}}



%%========================================
\paragraph{\texttt{Windows} \texttt{x64}.}
%%========================================
Аналогичная таблица для~\name{Windows}:
\begin{flushleft}\begin{tabular}{lll}
\toprule
  Регистр & Соглашение & Пояснение \\
\midrule
  \Reg{rax} & return value & аккумулятор \\
  \Reg{rbx} & callee saved & \\
  \Reg{rcx} & 1st argument & \\
  \Reg{rdx} & 2nd argument & \\[0.2em]
%
  \Reg{rsi} & callee saved & регистр общего назначения \\
  \Reg{rdi} & callee saved & регистр общего назначения \\
  \Reg{rbp} & callee saved & указатель начала кадра стека процедуры \\
  \Reg{rsp} & stack pointer & \\[0.2em]
%
  \Reg{r8}  & 3rd argument & \\
  \Reg{r9}  & 4th argument & \\
  \Reg{r10} & caller saved & используется в~syscall/sysret инструкциях \\
  \Reg{r11} & caller saved & используется в~syscall/sysret инструкциях \\[0.2em]
%
  \Reg{r12} & callee saved & регистр общего назначения \\
  \Reg{r13} & callee saved & регистр общего назначения \\
  \Reg{r14} & callee saved & регистр общего назначения \\
  \Reg{r15} & callee saved & регистр общего назначения \\
\bottomrule
\end{tabular}\end{flushleft}

Первые~4 целочисленных аргумента, размер которых не~превосходит 8~байт, передаются через регистры~\Reg{rcx}, \Reg{rdx}, \Reg{r8}, \Reg{r9}. Остальные аргументы сохраняются в~стек перед вызовом в~обратном порядке, как и в~\name{Linux}.
} % \Reg

На~момент входа в~функцию указатель стека обязан быть выровнен по~границе 16~байт. Это означает, что перед выполнением команды вызова \code{call} указатель стека должен быть кратен 8~байтам, но не~16 одновременно. (Она записывает на~вершину стека адрес возврата, а это те самые 8~байт, которые сделают указатель стека кратным~16.)



%%=============================
\section{Рекурсивные процедуры}
%%=============================

%%=====================
\paragraph{Упражнение.}
%%=====================
Ниже приведена общая структура функции на~\lang{C}:

{\newcommand*{\ans}{\ansfw{4em}}%
  %
  \begin{ccode*}{linenos=false}
    long rfun (unsigned long x)
    {
      if (|\ans{x == 0}|) return |\ans{0}|;

      unsigned long nx = |\ans{x >> 2}|;
      long rv = rfun (nx);

      return |\ans{x + rv}|;
    }
  \end{ccode*}
}

\noindent для которой \GCC{} выдаёт следующий код:

\gasfile[firstline=5, lastline=17]{projects/sem11/rfun.s}

\begin{enumIssue}
  \item Какое значение функция \code{rfun} сохраняет в~\textenglish{callee-saved} регистре \code{\%rbx}?
  \item Заполните пропущенные в~\lang{C} коде выражения.
\end{enumIssue}



%%================
\WhatToReadSection
%%================
\citeauthor[глава~3, стр.~250--264]{Bryant:2022:ru}



%%===============
\ExercisesSection
%%===============
Напишите функцию, которая принимает текстовую строку (в~стиле~\lang{C}) и возвращает~\code{1}, если она оканчивается заглавной латинской буквой, которая более не~встречается в~тексте, и~\code{0} в~противном случае.



%%========================================
\paragraph{Реализация на~языке~\lang{Си}.}
%%========================================
Начать следует с~комментария в~шапке файла \code{check.c}, где полезно привести формулировку проверяемого свойства:

\cfile[lastline=2]{projects/sem11/task/check.c}

Алгоритм проверки прост и состоит из~трёх отдельных действий. Его можно записать следующим образом:

\cfile[firstline=29]{projects/sem11/task/check.c}

\noindent Отметим, что далее предполагается использование компилятора \GCC{} из~пакета \name{MinGW-64} для~ОС \name{Windows}. Чтобы оставаться в~соглашениях \name{SYSV}~\name{ABI}, принятых в~ОС \name{Linux} и которых мы до~сих пор придерживались, перед заголовком функции добавлен соответствующий атрибут. При~компиляции в~\name{Linux} эти атрибуты излишни, их можно опустить.

Вспомогательная функция \code{last\_of()} возвращает последний символ строки~\code{s}:

\cfile[firstline=7, lastline=16]{projects/sem11/task/check.c}

\noindent Мы добавили квалификатор \code{static}, указав компилятору, что функция должна быть видна только в~пределах данного модуля (файла) и недоступна извне. Это одно из~средств сокрытия деталей реализации, которые не~входят в~интерфейс и могут измениться в~новой версии.

Следует помнить о~проверке указателей! Разыменование нулевого указателя недопустимо! Обработка ошибок усложняет логику, и хотелось бы избежать этого в~ассемблерной версии. Простым решением может служить вызов функции \code{abort()} из~\code{<stdlib.h>}. Однако это не~позволяет простым образом выяснить, где произошла ошибка, и требует вывода дополнительного сообщения на~экран.

В~языке~\lang{C++} можно использовать механизм исключений. Хотя, повторить подобные действия компилятора в~ассемблерной версии потребует определённых усилий, в~том числе по~изучению особенностей конкретной платформы. Это остаётся за~рамками нашего курса.

Мы решили вставить проверку предусловия через макрос \code{assert()} из~стандартной библиотеки \code{<assert>}, чтобы напомнить о~важном аспекте при~работе с~указателями. Релиз-версия, как правило, игнорирует такие проверки, объявляя макрос \code{NDEBUG}.

Функция \code{isupper()} реализована в~стандартной библиотеке \code{<ctype.h>} и возвращает~\code{1}, если символ в~верхнем регистре. А функция \code{count()} подсчитывает количество вхождений символа~\code{c} в~строку~\code{s} следующим образом:

\cfile[firstline=18, lastline=27]{projects/sem11/task/check.c}



%%=======================
\paragraph{Тестирование.}
%%=======================
Как всегда, чтобы убедиться в~работоспособности нашей реализации, необходимо написать небольшую <<тестовую оснастку>> (\code{main.cpp}). Для~удобства и выразительности кода определим вспомогательный тип \code{PropertyUnitTest}:

\cppfile[firstline=11, lastline=11]{projects/sem11/task/main.cpp}

\noindent Напомним, что тип \code{pair} из~\code{<utility>} способен хранить пару элементов разного типа. Теперь функция \code{main()} может выглядеть так:

\cppfile[firstline=35]{projects/sem11/task/main.cpp}

Вспомогательная функция \code{max\_width()} возвращает размер наиболее длинной строки среди данных тестов:

\cppfile[firstline=24, lastline=33]{projects/sem11/task/main.cpp}

\noindent Она использует \code{max\_element()} из~стандартной библиотеки шаблонов \code{<algorithm>}. В~данном случае нам необходимо указать, каким образом сравнивать элементы.

И, наконец, функция \code{run()} запускает тест, передавая данные нашей функции

\cppfile[firstline=9, lastline=9]{projects/sem11/task/main.cpp}

\noindent и выводит краткий отчёт об~успешности его выполнения:

\cppfile[firstline=13, lastline=22]{projects/sem11/task/main.cpp}

{\newcommand*{\cpprefurl}{https://en.cppreference.com/w/cpp/string/basic_string}
Отметим, что со~времени выхода стандарта \lang{C++11}, контейнер \href{\cpprefurl}{\code{std::string}}\footnote{\nolinkurl{\cpprefurl}} обязан хранить нулевой байт в~качестве завершающего элемента с~индексом \code{s.size()}.
}



%%=================
\paragraph{Сборка.}
%%=================
Собрать и запустить исполняемый файл можно следующими командами:
\begin{consolecode}
$ gcc -c check.c && g++ -o prog -std=c++17 main.cpp check.o
$ ./prog
\end{consolecode}

\noindent При~успешном выполнении всех тестов мы получим примерно такой вывод на~экране:

\textfile{projects/sem11/task/log}



%%=========================================
\paragraph{Реализация на~языке ассемблера.}
%%=========================================
Код, показанный выше, помогает нам легко и быстро реализовать ассемблерную версию. Мы уже проработали и отладили алгоритм, а также подготовили тесты. Язык ассемблера даёт максимальную свободу при~написании кода, но всю ответственность с~этого момента несёт сам программист, ибо ассемблер не~отслеживает некорректную работу с~типами данных и памятью.

В~шапку файла \code{check\_win-sysv.s} также добавим комментарий с~формулировкой проверяемого свойства:

\gasfile[lastline=2]{projects/sem11/task/check_win-sysv.s}

Интерфейсная функция должна быть доступна извне (директива \code{.globl}):

\gasfile[firstline=33]{projects/sem11/task/check_win-sysv.s}

\noindent Следует помнить о~порядке использования регистров. В~функции \code{check\_property()} мы используем соглашения \name{SYSV}~\name{ABI}, в~то время как функция \code{isupper()} из~стандартной библиотеки уже скомпилирована под~\name{Windows}, и, соответственно, необходимо вызывать её, передавая первый параметр в~регистре \code{\%ecx}, как это принято в~ОС \name{Windows}.

Как видно, мы имеем право смешивать соглашения, ассемблер даёт максимальную гибкость. Но, проверять нас никто не~будет, поэтому необходимо обо всех деталях помнить самому программисту, что значительно усложняет разработку кода. В~противном случае, ошибки неизбежны и заканчиваются неожиданным крахом при~выполнении.

Оставшиеся функции пишем по~шаблону версий на~\lang{Си} в~соглашениях \name{Linux}. Первая функция \code{last\_of()}:

\gasfile[firstline=4, lastline=14]{projects/sem11/task/check_win-sysv.s}

\noindent и вторая функция \code{count()}:

\gasfile[firstline=17, lastline=30]{projects/sem11/task/check_win-sysv.s}

Обе функции локальные, об~этом говорит квалификатор \code{static} при~объявлении в~Си. Поэтому не~нужно давать директиву \code{.globl} для~них. И если не~указано иначе, по~умолчанию мы работаем в~сегменте кода (директива \code{.text}).



%%=======================
\paragraph{Тестирование.}
%%=======================
Собрать исполняемый файл можно одной командой:

\console/$ g++ -o prog -std=c++17 main.cpp check_win-sysv.s/%$

Тестовая оснастка уже готова. Нам остаётся лишь добиться работоспособности кода, чтобы все тесты были успешно выполнены.
